<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>React.js 基本原理介绍 | SmileLJZ 个人博客</title><meta name="description" content="免责声明：该文章仅作为学习笔记使用，如需了解详情，请看原作者：sunshine小小倩，链接：https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;599156cc6fb9a03c3a25db08  React 全部都是组件化的React 是围绕可重用组件的概念设计的。你定义小组件并将它们组合在一起形成更大的组件。 无论大小，所有组件都是可重用的，甚至在不同的项目中也是如此。 React 组件最简单的形式"><meta name="keywords" content="reactjs,基本运行原理"><meta name="author" content="SmileLJZ"><meta name="copyright" content="SmileLJZ"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://smileljz.github.io/2020/07/24/React-js-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="React.js 基本原理介绍"><meta property="og:url" content="https://smileljz.github.io/2020/07/24/React-js-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/"><meta property="og:site_name" content="SmileLJZ 个人博客"><meta property="og:description" content="免责声明：该文章仅作为学习笔记使用，如需了解详情，请看原作者：sunshine小小倩，链接：https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;599156cc6fb9a03c3a25db08  React 全部都是组件化的React 是围绕可重用组件的概念设计的。你定义小组件并将它们组合在一起形成更大的组件。 无论大小，所有组件都是可重用的，甚至在不同的项目中也是如此。 React 组件最简单的形式"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-07-24T04:35:29.000Z"><meta property="article:modified_time" content="2020-07-24T11:46:31.786Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="VUE总结" href="https://smileljz.github.io/2020/08/05/VUE%E6%80%BB%E7%BB%93/"><link rel="next" title="javascript相关知识" href="https://smileljz.github.io/2020/07/21/javascript%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="SmileLJZ 个人博客" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://pic.downk.cc/item/5f040b5a14195aa5946dfd5f.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#React-全部都是组件化的"><span class="toc-number">1.</span> <span class="toc-text">React 全部都是组件化的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSX-输出的是什么？"><span class="toc-number">2.</span> <span class="toc-text">JSX 输出的是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#你可以在-JavaScript-的任何地方使用-JSX"><span class="toc-number">3.</span> <span class="toc-text">你可以在 JavaScript 的任何地方使用 JSX</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#你可以使用-JavaScript-类写-React-组件"><span class="toc-number">4.</span> <span class="toc-text">你可以使用 JavaScript 类写 React 组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-中的事件：两个重要的区别"><span class="toc-number">5.</span> <span class="toc-text">React 中的事件：两个重要的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#每一个-React-组件都有一个故事：第-1-部分"><span class="toc-number">6.</span> <span class="toc-text">每一个 React 组件都有一个故事：第 1 部分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-组件可以具有私有状态"><span class="toc-number">7.</span> <span class="toc-text">React 组件可以具有私有状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-将要反应"><span class="toc-number">8.</span> <span class="toc-text">React 将要反应</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-是你的代码"><span class="toc-number">9.</span> <span class="toc-text">React 是你的代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#每一个-React-组件都有一个故事：第-2-部分"><span class="toc-number">10.</span> <span class="toc-text">每一个 React 组件都有一个故事：第 2 部分</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SmileLJZ 个人博客</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">React.js 基本原理介绍</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-24 12:35:29"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-24 19:46:31"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-24</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/react/">react</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p>免责声明：<br><br>该文章仅作为学习笔记使用，如需了解详情，请看原作者：sunshine小小倩，链接：<a href="https://juejin.im/post/599156cc6fb9a03c3a25db08" target="_blank" rel="noopener">https://juejin.im/post/599156cc6fb9a03c3a25db08</a><br></p>
</blockquote>
<h1 id="React-全部都是组件化的"><a href="#React-全部都是组件化的" class="headerlink" title="React 全部都是组件化的"></a>React 全部都是组件化的</h1><p><code>React</code> 是围绕可重用组件的概念设计的。你定义小组件并将它们组合在一起形成更大的组件。</p>
<p>无论大小，所有组件都是可重用的，甚至在不同的项目中也是如此。</p>
<p><code>React</code> 组件最简单的形式，就是一个普通的 <code>JavaScript</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里返回一个 DOM 元素，例如：</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>&#123;props.label&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将按钮组件呈现给浏览器</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">label</span>=<span class="string">"Save"</span> /&gt;</span></span>, mountNode)</span><br></pre></td></tr></table></figure>

<p>例 1 的注意事项：</p>
<ul>
<li>组件名称首字母大写，<code>Button</code>。必须要这样做是因为我们将处理 <code>HTML</code> 元素和 <code>React</code> 元素的混合。小写名称是为 <code>HTML</code> 元素保留的。事实上，将 <code>React</code> 组件命名为 “button” 然后你就会发现 <code>ReactDOM</code> 会忽略这个函数，仅仅是将其作为一个普通的空 <code>HTML</code> 按钮来渲染。</li>
<li>每个组件都接收一个属性列表，就像 <code>HTML</code> 元素一样。在 <code>React</code> 中，这个列表被称为属性。虽然你可以将一个函数随意命名。</li>
<li>在上面 Button 函数组件的返回输出中，我们奇怪地写了段看上去像 <code>HTML</code> 的代码。这实际上既不是 JavaScript 也不是 <code>HTML</code>，老实说，这甚至不是 <code>React.js</code>。然而它非常流行，以至于成为 <code>React</code> 应用程序中的默认值。这就是所谓的 <code>JSX</code>，这是一个JavaScript 的扩展。<code>JSX</code> 也是一个折中方案！继续尝试并在上面的函数中返回其他 <code>HTML</code> 元素，看看它们是如何被支持的（例如，返回一个文本输入元素）。</li>
</ul>
<hr>
<h1 id="JSX-输出的是什么？"><a href="#JSX-输出的是什么？" class="headerlink" title="JSX 输出的是什么？"></a>JSX 输出的是什么？</h1><p>上面的例 1 可以用没有 JSX 的纯 React.js 编写，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">"button"</span>,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"submit"</span> &#125;,</span><br><span class="line">    props.label</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要使用 Button，你可以这么做</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Button, &#123; <span class="attr">label</span>: <span class="string">"Save"</span> &#125;),</span><br><span class="line">  mountNode</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>例 2：不使用 JSX 编写 React 组件</p>
<p>在 <code>React</code> 顶级 API 中，<code>createElement</code> 函数是主函数。这是你需要学习的 7 个 API 中的 1 个。React 的 API 就是这么小。<br>就像 DOM 自身有一个 <code>document.createElement</code> 函数来创建一个由标签名指定的元素一样，<code>React</code> 的 <code>createElement</code> 函数是一个高级函数，有和 <code>document.createElement</code> 同样的功能，但它也可以用于创建一个表示 <code>React</code>组件的元素。当我们使用上面例 2 中的按钮组件时，我们使用的是后者。<br>不像 <code>document.createElement</code>，<code>React</code> 的 <code>createElement</code>在接收第二个参数后，接收一个动态参数，它表示所创建元素的子元素。所以 <code>createElement</code> 实际上创建了一个<strong>树</strong>。<br>这里就是这样的一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> InputForm = React.createElement(</span><br><span class="line">  <span class="string">"form"</span>,</span><br><span class="line">  &#123; <span class="attr">target</span>: <span class="string">"_blank"</span>, <span class="attr">action</span>: <span class="string">"https://google.com/search"</span> &#125;,</span><br><span class="line">  React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">"Enter input and click Search"</span>),</span><br><span class="line">  React.createElement(<span class="string">"input"</span>, &#123; <span class="attr">className</span>: <span class="string">"big-input"</span> &#125;),</span><br><span class="line">  React.createElement(Button, &#123; <span class="attr">label</span>: <span class="string">"Search"</span> &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// InputForm 使用 Button 组件，所以我们需要这样做：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">"button"</span>,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"submit"</span> &#125;,</span><br><span class="line">    props.label</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后我们可以通过 .render 方法直接使用 InputForm</span></span><br><span class="line">ReactDOM.render(InputForm, mountNode);</span><br></pre></td></tr></table></figure>
<p>例 3：React 创建元素的 API</p>
<p>上面例子中的一些事情值得注意：</p>
<ul>
<li><p><code>InputForm</code> 不是一个 <code>React</code> 组件；它仅仅是一个 <code>React</code> 元素。这就是为什么我们可以在 <code>ReactDOM.render</code> 中直接使用它并且可以在调用时不使用 <code>&lt;InputForm /&gt;</code> 的原因。</p>
</li>
<li><p><code>React.createElement</code> 函数在前两个参数后接收了多个参数。从第3个参数开始的参数列表构成了创建元素的子项列表。</p>
</li>
<li><p>我们可以嵌套 <code>React.createElement</code> 调用，因为它是 <strong>JavaScript</strong>。</p>
</li>
<li><p>当这个元素不需要属性时，<code>React.createElement</code> 的第二个参数可以为空或者是一个空对象。</p>
</li>
<li><p>我们可以在 <code>React</code> 组件中混合 <code>HTML</code> 元素。你可以将 <code>HTML</code> 元素作为内置的 <code>React</code> 组件。</p>
</li>
<li><p><code>React</code> 的 <strong>API</strong> 试图和 <strong>DOM API</strong> 一样，这就是为什么我们在 <code>input</code> 元素中使用 <code>className</code> 代替 <code>class</code> 的原因。</p>
</li>
</ul>
<p>上述的代码是当你引入 <code>React</code> 库的时候浏览器是怎样理解的。浏览器不会处理任何 JSX 业务。然而，我们更喜欢看到和使用 HTML，而不是那些 <code>createElement</code> 调用（想象一下只使用 <code>document.createElement</code> 构建一个网站！）。这就是 <code>JSX</code> 存在的原因。取代上述调用 <code>React</code>.createElement 的方式，我们可以使用一个非常简单类似于 HTML 的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const InputForm &#x3D;</span><br><span class="line">  &lt;form target&#x3D;&quot;_blank&quot; action&#x3D;&quot;https:&#x2F;&#x2F;google.com&#x2F;search&quot;&gt;</span><br><span class="line">    &lt;div&gt;Enter input and click Search&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;input className&#x3D;&quot;big-input&quot; name&#x3D;&quot;q&quot; &#x2F;&gt;</span><br><span class="line">    &lt;Button label&#x3D;&quot;Search&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;form&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; InputForm “仍然”使用 Button 组件，所以我们也需要这样。</span><br><span class="line">&#x2F;&#x2F; JXS 或者普通的表单都会这样做</span><br><span class="line">function Button (props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里返回一个 DOM 元素。例如：</span><br><span class="line">  return &lt;button type&#x3D;&quot;submit&quot;&gt;&#123;props.label&#125;&lt;&#x2F;button&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后我们可以直接通过 .render 使用 InputForm</span><br><span class="line">ReactDOM.render(InputForm, mountNode);</span><br></pre></td></tr></table></figure>
<p>例 4：为什么在 React 中 JSX 受欢迎（和例 3 相比）</p>
<p>注意上面的几件事：</p>
<ul>
<li>这不是 <code>HTML</code> 代码。比如，我们仍然可以使用 <code>className</code> 代替 <code>class</code>。</li>
<li>我们仍在考虑怎样让上述的 <strong>JavaScript</strong> 看起来像是 <strong>HTML</strong>。看一下我在最后是怎样添加的。</li>
</ul>
<p>我们在上面（例 4）中写的就是 JSX。然而，我们要将编译后的版本（例 3）给浏览器。要做到这一点，我们需要使用一个预处理器将 JSX 版本转换为 <code>React.createElement</code> 版本。</p>
<p>这就是 JSX。这是一种折中的方案，允许我们用类似 HTML 的语法来编写我们的 React 组件，这是一个很好的方法。</p>
<blockquote>
<p>JSX，可以单独使用，不仅仅适用于 React。</p>
</blockquote>
<h1 id="你可以在-JavaScript-的任何地方使用-JSX"><a href="#你可以在-JavaScript-的任何地方使用-JSX" class="headerlink" title="你可以在 JavaScript 的任何地方使用 JSX"></a>你可以在 JavaScript 的任何地方使用 JSX</h1><p>在 JSX 中，你可以在一对花括号内使用任何 JavaScript 表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const RandomValue &#x3D; () &#x3D;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; Math.floor(Math.random() * 100) &#125;</span><br><span class="line">  &lt;&#x2F;div&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用：</span><br><span class="line">ReactDOM.render(&lt;RandomValue &#x2F;&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<p>例 5：在 JSX 中使用 JavaScript 表达式</p>
<p>任何 <strong>JavaScript</strong> 表达式可以直接放在花括号中。这相当于在 <strong>JavaScript</strong> 中插入 <code>${}</code> 模板。</p>
<p>这是 JSX 内唯一的约束：只有表达式。例如，你不能使用 <code>if</code> 语句，但三元表达式是可以的。</p>
<p><strong>JavaScript</strong> 变量也是表达式，所以当组件接受属性列表时（不包括 <code>RandomValue</code> 组件，<code>props</code> 是可选择的），你可以在花括号里使用这些属性。我们在上述（例 1）的 <code>Button</code> 组件是这样使用的。</p>
<p><strong>JavaScript</strong> 对象也是表达式。有些时候我们在花括号中使用 <strong>JavaScript</strong> 对象，这看起来像是使用了两个花括号，但是在花括号中确实只有一个对象。其中一个用例就是将 <strong>CSS</strong> 样式对象传递给响应中的特殊样式属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const ErrorDisplay &#x3D; (&#123;message&#125;) &#x3D;&gt;&#123;</span><br><span class="line">  &lt;div style&#x3D;&#123; &#123; color: &#39;red&#39;, backgroundColor: &#39;yellow&#39; &#125; &#125;&gt;</span><br><span class="line">    &#123;message&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ErrorDisplay</span><br><span class="line">    message&#x3D;&quot;These aren&#39;t the droids you&#39;re looking for&quot;</span><br><span class="line">  &#x2F;&gt;,</span><br><span class="line">  mountNode</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>例 6：一个对象传递特殊的 React 样式参数</p>
<p>注意我解构的只是在属性参数之外的信息。这只是 JavaScript。还要注意上面的样式属性是一个特殊的属性（同样，它不是 HTML，它更接近 DOM API）。我们使用一个对象作为样式属性的值并且这个对象定义样式就像我们使用 JavaScript 那样（我们可以这样做）。</p>
<p>你可以在 JSX 中使用 React 元素。因为这也是一个表达式（记住，一个 React 元素只是一个函数调用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const MaybeError &#x3D; (&#123;errorMessage&#125;) &#x3D;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;errorMessage &amp;&amp; &lt;ErrorDisplay message&#x3D;&#123;errorMessage&#125; &#x2F;&gt;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; MaybeError 组件使用 ErrorDisplay 组件</span><br><span class="line">const ErrorDisplay &#x3D; (&#123;message&#125;) &#x3D;&gt;</span><br><span class="line">  &lt;div style&#x3D;&#123; &#123; color: &#39;red&#39;, backgroundColor: &#39;yellow&#39; &#125; &#125;&gt;</span><br><span class="line">    &#123;message&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 现在我们使用 MaybeError 组件：</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MaybeError</span><br><span class="line">    errorMessage&#x3D;&#123;Math.random() &gt; 0.5 ? &#39;Not good&#39; : &#39;&#39;&#125;</span><br><span class="line">  &#x2F;&gt;,</span><br><span class="line">  mountNode</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>例 7：一个 React 元素是一个可以通过 {} 使用的表达式</p>
<p>上述 <code>MaybeError</code> 组件只会在有 <code>errorMessage</code> 传入或者另外有一个空的 <code>div</code> 才会显示 <code>ErrorDisplay</code> 组件。<strong>React</strong> 认为 <code>{true}</code>、 <code>{false}</code>   <code>{undefined}</code>  和 <code>{null}</code> 是有效元素，不呈现任何内容。<br>我们也可以在 <strong>JSX</strong> 中使用所有的 <strong>JavaScript</strong> 的集合方法（<code>map</code>、<code>reduce</code> 、<code>filter</code>、 <code>concat</code> 等）。因为他们返回的也是表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const Doubler &#x3D; (&#123;value&#x3D;[1, 2, 3]&#125;) &#x3D;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;value.map(e &#x3D;&gt; e * 2)&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用下面内容 </span><br><span class="line">ReactDOM.render(&lt;Doubler &#x2F;&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<p>例 8：在 {} 中使用数组</p>
<p>请注意我是如何给出上述 <code>value</code> 属性的默认值的，因为这全部都只是 <strong>JavaScript</strong>。注意我只是在 <strong>div</strong> 中输出一个数组表达式。<strong>React</strong> 是完全可以的。它只会在文本节点中放置每一个加倍的值。</p>
<hr>
<h1 id="你可以使用-JavaScript-类写-React-组件"><a href="#你可以使用-JavaScript-类写-React-组件" class="headerlink" title="你可以使用 JavaScript 类写 React 组件"></a>你可以使用 JavaScript 类写 React 组件</h1><p>简单的函数组件非常适合简单的需求，但是有的时候我们需要的更多。<strong>React</strong> 也支持通过使用 JavaScript 类来创建组件。这里 <code>Button</code> 组件（在例 1 中）就是使用类的语法编写的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>&#123;this.props.label&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用（相同的语法）</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">label</span>=<span class="string">"Save"</span> /&gt;</span></span>, mountNode);</span><br></pre></td></tr></table></figure>
<p>例 9：使用 JavaScript 类创建组件</p>
<p>类的语法是非常简单的：定义一个扩展的 <code>React.Component</code> 类（另一个你需要学习的 React 的顶级 API）。该类定义了一个单一的实例函数 —— <code>render()</code>，并使函数返回虚拟 DOM 对象。每一次我们使用基于类的 <code>Button</code> 组件（例如，通过 <code>&lt;Button ... /&gt;</code>）,React 将从这个基于类的组件中实例化对象，并在 <strong>DOM</strong> 树中使用该对象。</p>
<p>这就是为什么上面的例子中我们可以在 <strong>JSX</strong> 中使用 <code>this.props.label</code> 渲染输出的原因，因为每一个组件都有一个特殊的称为 <code>props</code> 的 <strong>实例</strong> 属性，这让所有的值传递给该组件时被实例化。</p>
<p>由于我们有一个与组件的单个使用相关联的实例，所以我们可以按照自己的意愿定制该实例。例如，我们可以通过使用常规 <strong>JavaScript</strong> 构造函数来构造它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="built_in">Date</span>.now();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&#123;this.id&#125;</span>&gt;</span>&#123;this.props.label&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">label</span>=<span class="string">"Save"</span> /&gt;</span></span>, mountNode);</span><br></pre></td></tr></table></figure>
<p>例 10：自定义组件实例</p>
<p>我们也可以定义类的原型并且在任何我们希望的地方使用，包括在返回的 JSX 输出的内部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  clickCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Clicked: <span class="subst">$&#123;++<span class="keyword">this</span>.clickCounter&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button id=&#123;<span class="keyword">this</span>.id&#125; onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.label&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Button label="Save" /</span>&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<p>例 11：使用类的属性（通过单击保存按钮进行测试）</p>
<p>注意上述例 11 中的几件事情</p>
<ul>
<li><code>handleClick</code> 函数使用 <strong>JavaScript</strong> 新提出的 <code>class-field syntax</code>语法。这仍然是 <strong>stage-2</strong>，但是这是访问组件安装实例（感谢箭头函数）最好的选择（因为很多原因）。然而，你需要使用类似 <strong>Babel</strong> 的编译器解码为 <strong>stage-2</strong>（或者仅仅是类字段语法）来让上述代码工作。 jsComplete REPL 有预编译功能。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：</span></span><br><span class="line">onClick=&#123;<span class="keyword">this</span>.handleClick()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：</span></span><br><span class="line">onClick=&#123;<span class="keyword">this</span>.handleClick&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="React-中的事件：两个重要的区别"><a href="#React-中的事件：两个重要的区别" class="headerlink" title="React 中的事件：两个重要的区别"></a>React 中的事件：两个重要的区别</h1><p>当处理 React 元素中的事件时，我们与 DOM API 的处理方式有两个非常重要的区别：</p>
<ul>
<li>所有 React 元素属性（包括事件）都使用 <strong>camelCase</strong> 命名，而不是 <strong>lowercase</strong>。例如是 <code>onClick</code> 而不是 <code>onclick</code>。</li>
<li>我们将实际的 JavaScript 函数引用传递给事件处理程序，而不是字符串。例如是 <code>onClick={handleClick}</code> 而不是 <code>onClick=&quot;handleClick&quot;</code>。</li>
</ul>
<p><strong>React</strong> 用自己的对象包装 <strong>DOM</strong> 对象事件以优化事件处理的性能，但是在事件处理程序内部，我们仍然可以访问 <strong>DOM</strong> 对象上所有可以访问的方法。<strong>React</strong> 将经过包装的事件对象传递给每个调用函数。例如，为了防止表单提交默认提交操作，你可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Form submitted'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Form</span> /&gt;</span></span>, mountNode);</span><br></pre></td></tr></table></figure>
<p>例 12：使用包装过的对象</p>
<hr>
<h1 id="每一个-React-组件都有一个故事：第-1-部分"><a href="#每一个-React-组件都有一个故事：第-1-部分" class="headerlink" title="每一个 React 组件都有一个故事：第 1 部分"></a>每一个 React 组件都有一个故事：第 1 部分</h1><p>以下仅适用于类组件（扩展 <code>React.Component</code>）。函数组件有一个稍微不同的故事。</p>
<ol>
<li>首先，我们定义了一个模板来创建组件中的元素。</li>
<li>然后，我们在某处使用 <strong>React</strong>。例如，在 <code>render</code> 内部调用其他的组件，或者直接使用 <code>ReactDOM.render</code>。</li>
<li>然后，React 实例化一个对象然后给它设置 <strong>props</strong> 然后我们可以通过 <code>this.props</code> 访问。这些属性都是我们在第 2 步传入的。</li>
<li>因为这些全部都是 JavaScript，<code>constructor</code> 方法将会被调用（如果定义的话）。这是我们称之为的第一个：<strong>组件生命周期方法</strong>。</li>
<li>接下来 React 计算渲染之后的输出方法（虚拟 DOM 节点）。</li>
<li>因为这是 React 第一次渲染元素，React 将会与浏览器连通（代表我们使用 DOM API）来显示元素。这整个过程称为 <strong>mounting</strong>。</li>
<li>接下来 React 调用另一个生命周期函数，称为 <code>componentDidMount</code>。我们可以这样使用这个方法，例如：在 DOM 上做一些我们现在知道的在浏览器中存在的东西。在此生命周期方法之前，我们使用的 DOM 都是虚拟的。</li>
<li>一些组件的故事到此结束，其他组件得到卸载浏览器 DOM 中的各种原因。在后一种情况发生时，会调用另一个生命周期的方法，<code>componentWillUnmount</code>。</li>
<li>任何 mounted 的元素的<strong>状态</strong>都可能会改变。该元素的父级可能会重新渲染。无论哪种情况，mounted 的元素都可能接收到不同的属性集。React 的魔力就是这儿，我们实际上需要的正是 React 的这一点！在这一点之前，说实话，我们并不需要 React。</li>
<li>组价的故事还在继续，但是在此之前，我们需要理解我所说的这种<strong>状态</strong>。</li>
</ol>
<hr>
<h1 id="React-组件可以具有私有状态"><a href="#React-组件可以具有私有状态" class="headerlink" title="React 组件可以具有私有状态"></a>React 组件可以具有私有状态</h1><p>以下只适用于类组件。我有没有提到有人叫表象而已的部件 <strong>dumb</strong>？<br>状态类是任何 React 类组件中的一个特殊字段。React 检测每一个组件状态的变化，但是为了 React 更加有效，我们必须通过 React 的另一个 API 改变状态字段，这就是我们要学习的另一个 API —— <code>this.setState</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    clickCounter: <span class="number">0</span>,</span><br><span class="line">    currentTimestamp: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123; <span class="attr">clickCounter</span>: prevState.clickCounter + <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">   setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.setState(&#123; <span class="attr">currentTimestamp</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;Clicked: &#123;this.state.clickCounter&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;p&gt;Time: &#123;<span class="keyword">this</span>.state.currentTimestamp.toLocaleString()&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">CounterButton</span> /&gt;</span></span>, mountNode);</span><br></pre></td></tr></table></figure>
<p>例 13：setState 的 API</p>
<p>这可能是最重要的一个例子因为这将是你完全理解 React 基础知识的方式。这个例子之后，还有一些小事情需要学习，但从那时起主要是你和你的 JavaScript 技能。</p>
<p>让我们来看一下例 13，从类开始，总共有两个，一个是一个初始化的有初始值为 <code>0</code> 的 <code>clickCounter</code> 对象和一个从 <code>new Date()</code> 开始的 <code>currentTimestamp</code>。</p>
<p>另一个类是 <code>handleClick</code> 函数，在渲染方法中我们给按钮元素传入 <code>onClick</code> 事件。通过使用 <code>setState</code> 的 <code>handleClick</code> 方法修改了组件的实例状态。要注意到这一点。</p>
<p>另一个我们修改状态的地方是在一个内部的定时器，开始在内部的 <code>componentDidMount</code> 生命周期方法。它每秒钟调用一次并且执行另一个函数调用 <code>this.setState</code>。</p>
<p>在渲染方法中，我们使用具有正常读语法的状态上的两个属性（没有专门的 API）。</p>
<p>现在，注意我们更新状态使用两种不同的方式：</p>
<ol>
<li>通过传入一个函数然后返回一个对象。我们在 <code>handleClick</code> 函数内部这样做。</li>
<li>通过传入一个正则对象，我们在在区间回调中这样做。</li>
</ol>
<p>这两种方式都是可以接受的，但是当你同时读写状态时，第一种方法是首选的（我们这样做）。在区间回调中，我们只向状态写入而不读它。当有问题时，总是使用第一个函数作为参数语法。伴随着竞争条件这更安全，因为 <code>setstate</code> 实际上是一个异步方法。</p>
<p>我们应该怎样更新状态呢？我们返回一个有我们想要更新的的值的对象。注意，在调用 <code>setState</code> 时，我们全部都从状态中传入一个属性或者全都不。这完全是可以的因为 <code>setState</code> 实际上 合并 了你通过它（返回值的函数参数）与现有的状态，所以，没有指定一个属性在调用 <code>setState</code> 时意味着我们不希望改变属性（但不删除它）。</p>
<hr>
<h1 id="React-将要反应"><a href="#React-将要反应" class="headerlink" title="React 将要反应"></a>React 将要反应</h1><p>React 的名字是从状态改变的<strong>反应</strong>中得来的（虽然没有反应，但也是在一个时间表中）。这里有一个笑话，React 应该被命名为<strong>Schedule</strong>！</p>
<p>然而，当任何组件的状态被更新时，我们用肉眼观察到的是对该更新的反应，并自动反映了浏览器 DOM 中的更新（如果需要的话）。</p>
<p>将渲染函数的输入视为两种：</p>
<ul>
<li>通过父元素传入的属性</li>
<li>以及可以随时更新的内部私有状态</li>
</ul>
<p>当渲染函数的输入改变时，输出可能也会改变。</p>
<p>React 保存了渲染的历史记录，当它看到一个渲染与前一个不同时，它将计算它们之间的差异，并将其有效地转换为在 DOM 中执行的实际 DOM 操作。</p>
<hr>
<h1 id="React-是你的代码"><a href="#React-是你的代码" class="headerlink" title="React 是你的代码"></a>React 是你的代码</h1><p>您可以将 React 看作是我们用来与浏览器通信的代理。以上面的当前时间戳显示为例。取代每一秒我们都需要手动去浏览器调用 DOM API 操作来查找和更新 <code>p#timestamp</code> 元素，我们仅仅改变组件的状态属性，React 做的工作代表我们与浏览器的通信。我相信这就是为什么 React 这么受欢迎的真正原因；我们只是不喜欢和浏览器先生谈话（以及它所说的 DOM 语言的很多方言），并且 React 自愿传递给我们，免费的！</p>
<hr>
<h1 id="每一个-React-组件都有一个故事：第-2-部分"><a href="#每一个-React-组件都有一个故事：第-2-部分" class="headerlink" title="每一个 React 组件都有一个故事：第 2 部分"></a>每一个 React 组件都有一个故事：第 2 部分</h1><p>现在我们知道了一个组件的状态，当该状态发生变化的时候，我们来了解一下关于这个过程的最后几个概念。</p>
<ol>
<li>当组件的状态被更新时，或者它的父进程决定更改它传递给组件的属性时，组件可能需要重新渲染。</li>
<li>如果后者发生，React 会调用另一个生命周期方法：<code>componentWillReceiveProps</code>。</li>
<li>如果状态对象或传递的属性改变了，React 有一个重要的决定要做：组件是否应该在 DOM 中更新？这就是为什么它调用另一个重要的生命周期方法 <code>shouldComponentUpdate</code> 的原因 。此方法是一个实际问题，因此，如果需要自行定制或优化渲染过程，则必须通过返回 true 或 false 来回答这个问题。</li>
<li>如果没有自定义 <code>shouldComponentUpdate</code>，React 的默认事件在大多数情况下都能处理的很好。</li>
<li>首先，这个时候会调用另一生命周期的方法：<code>componentWillUpdate</code>。然后，React 将计算新渲染过的输出，并将其与最后渲染的输出进行对比。</li>
<li>如果渲染过的输出和之前的相同，React 不进行处理（不需要和浏览器先生对话）。</li>
<li>如果有不同的地方，React 将不同传达给浏览器，像我们之前看到的那样。</li>
<li>在任何情况下，一旦一个更新程序发生了，无论以何种方式（即使有相同的输出），React 会调用最后的生命周期方法：<code>componentDidUpdate</code>。</li>
</ol>
<p>生命周期方法是逃生舱口。如果你没有做什么特别的事情，你可以在没有它们的情况下创建完整的应用程序。它们非常方便地分析应用程序中正在发生的事情，并进一步优化 React 更新的性能。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SmileLJZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://smileljz.github.io/2020/07/24/React-js-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/">https://smileljz.github.io/2020/07/24/React-js-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://SmileLJZ.github.io" target="_blank">SmileLJZ 个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/reactjs/">reactjs</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/">基本运行原理</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/05/VUE%E6%80%BB%E7%BB%93/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">VUE总结</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/21/javascript%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">javascript相关知识</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By SmileLJZ</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script></body></html>