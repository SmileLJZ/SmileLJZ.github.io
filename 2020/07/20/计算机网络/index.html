<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>计算机网络 | SmileLJZ 个人博客</title><meta name="description" content="关于es6的一些语法和常用操作"><meta name="keywords" content="计算机网络,http/TCP"><meta name="author" content="SmileLJZ"><meta name="copyright" content="SmileLJZ"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://smileljz.github.io/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="计算机网络"><meta property="og:url" content="https://smileljz.github.io/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><meta property="og:site_name" content="SmileLJZ 个人博客"><meta property="og:description" content="关于es6的一些语法和常用操作"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-07-19T17:02:48.000Z"><meta property="article:modified_time" content="2020-07-20T11:20:11.737Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="TypeScript（5）" href="https://smileljz.github.io/2020/07/14/TypeScript%EF%BC%885%EF%BC%89/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="SmileLJZ 个人博客" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://pic.downk.cc/item/5f040b5a14195aa5946dfd5f.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简单讲解一下http2的多路复用"><span class="toc-number">1.</span> <span class="toc-text">简单讲解一下http2的多路复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#谈谈你对TCP三次握手和四次挥手的理解"><span class="toc-number">2.</span> <span class="toc-text">谈谈你对TCP三次握手和四次挥手的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍-HTTPS-握手过程"><span class="toc-number">3.</span> <span class="toc-text">介绍 HTTPS 握手过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTPS-握手过程中，客户端如何验证证书的合法性"><span class="toc-number">4.</span> <span class="toc-text">HTTPS 握手过程中，客户端如何验证证书的合法性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍下-HTTPS-中间人攻击"><span class="toc-number">5.</span> <span class="toc-text">介绍下 HTTPS 中间人攻击</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http1-0-http1-1-http2-0特性及区别"><span class="toc-number">6.</span> <span class="toc-text">http1.0 http1.1 http2.0特性及区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#http1-0特性"><span class="toc-number">6.1.</span> <span class="toc-text">http1.0特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无状态"><span class="toc-number">6.1.1.</span> <span class="toc-text">无状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无连接"><span class="toc-number">6.1.2.</span> <span class="toc-text">无连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http1-1特性"><span class="toc-number">6.2.</span> <span class="toc-text">http1.1特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#长连接"><span class="toc-number">6.2.1.</span> <span class="toc-text">长连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道化"><span class="toc-number">6.2.2.</span> <span class="toc-text">管道化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存处理"><span class="toc-number">6.2.3.</span> <span class="toc-text">缓存处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#断点传输"><span class="toc-number">6.2.4.</span> <span class="toc-text">断点传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http2-0特性"><span class="toc-number">6.3.</span> <span class="toc-text">http2.0特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制分帧"><span class="toc-number">6.3.1.</span> <span class="toc-text">二进制分帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用"><span class="toc-number">6.3.2.</span> <span class="toc-text">多路复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区别"><span class="toc-number">6.4.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#永久性重定向（301）和临时性重定向（302）对-SEO-有什么影响"><span class="toc-number">7.</span> <span class="toc-text">永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Http-状态码-301-和-302-的应用场景分别是什么"><span class="toc-number">8.</span> <span class="toc-text">Http 状态码 301 和 302 的应用场景分别是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口如何防刷"><span class="toc-number">9.</span> <span class="toc-text">接口如何防刷</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么-HTTP1-1-不能实现多路复用"><span class="toc-number">10.</span> <span class="toc-text">为什么 HTTP1.1 不能实现多路复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP报文结构是什么"><span class="toc-number">11.</span> <span class="toc-text">HTTP报文结构是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP请求方法有哪些"><span class="toc-number">12.</span> <span class="toc-text">HTTP请求方法有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对URI是如何理解的"><span class="toc-number">13.</span> <span class="toc-text">对URI是如何理解的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对HTTP状态码的了解"><span class="toc-number">14.</span> <span class="toc-text">对HTTP状态码的了解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#说说HTTP特点以及缺点"><span class="toc-number">15.</span> <span class="toc-text">说说HTTP特点以及缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对Accept字段的理解"><span class="toc-number">16.</span> <span class="toc-text">对Accept字段的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是队头阻塞问题"><span class="toc-number">17.</span> <span class="toc-text">什么是队头阻塞问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对HTTP代理的理解"><span class="toc-number">18.</span> <span class="toc-text">对HTTP代理的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#强缓存"><span class="toc-number">18.1.</span> <span class="toc-text">强缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协商缓存"><span class="toc-number">18.2.</span> <span class="toc-text">协商缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关于HTTP-2"><span class="toc-number">19.</span> <span class="toc-text">关于HTTP&#x2F;2</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SmileLJZ 个人博客</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">计算机网络</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-20 01:02:48"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-20</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-20 19:20:11"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-20</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="简单讲解一下http2的多路复用"><a href="#简单讲解一下http2的多路复用" class="headerlink" title="简单讲解一下http2的多路复用"></a>简单讲解一下http2的多路复用</h1><p>在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：</p>
<ul>
<li>第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</li>
<li>第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。</li>
</ul>
<p>HTTP/2的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
<hr>
<h1 id="谈谈你对TCP三次握手和四次挥手的理解"><a href="#谈谈你对TCP三次握手和四次挥手的理解" class="headerlink" title="谈谈你对TCP三次握手和四次挥手的理解"></a>谈谈你对TCP三次握手和四次挥手的理解</h1><p>比喻：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">男：我要挂了哦 </span><br><span class="line">女：等哈，我还要敷面膜 </span><br><span class="line">女：我敷完了，现在可以挂了 </span><br><span class="line">男：我舍不得挂，你挂吧 </span><br><span class="line">女：好吧，我挂了 </span><br><span class="line">男：等了2MSL听见嘟嘟嘟的声音后挂断</span><br></pre></td></tr></table></figure>
<p>图解：<br><img src= "/img/loading.gif" data-src="https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png" alt></p>
<hr>
<h1 id="介绍-HTTPS-握手过程"><a href="#介绍-HTTPS-握手过程" class="headerlink" title="介绍 HTTPS 握手过程"></a>介绍 HTTPS 握手过程</h1><ol>
<li>客户端使用https的url访问web服务器,要求与服务器建立ssl连接</li>
<li>web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端</li>
<li>客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥</li>
<li>客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥</li>
<li>之后服务器与客户端使用秘钥加密传输</li>
</ol>
<hr>
<h1 id="HTTPS-握手过程中，客户端如何验证证书的合法性"><a href="#HTTPS-握手过程中，客户端如何验证证书的合法性" class="headerlink" title="HTTPS 握手过程中，客户端如何验证证书的合法性"></a>HTTPS 握手过程中，客户端如何验证证书的合法性</h1><ol>
<li><p>首先什么是HTTP协议? http协议是超文本传输协议，位于tcp/ip四层模型中的应用层；通过请求/响应的方式在客户端和服务器之间进行通信；但是缺少安全性，http协议信息传输是通过明文的方式传输，不做任何加密，相当于在网络上裸奔；容易被中间人恶意篡改，这种行为叫做中间人攻击； </p>
</li>
<li><p>加密通信： 为了安全性，双方可以使用对称加密的方式key进行信息交流，但是这种方式对称加密秘钥也会被拦截，也不够安全，进而还是存在被中间人攻击风险； 于是人们又想出来另外一种方式，使用非对称加密的方式；使用公钥/私钥加解密；通信方A发起通信并携带自己的公钥，接收方B通过公钥来加密对称秘钥；然后发送给发起方A；A通过私钥解密；双发接下来通过对称秘钥来进行加密通信；但是这种方式还是会存在一种安全性；中间人虽然不知道发起方A的私钥，但是可以做到偷天换日，将拦截发起方的公钥key;并将自己生成的一对公/私钥的公钥发送给B；接收方B并不知道公钥已经被偷偷换过；按照之前的流程，B通过公钥加密自己生成的对称加密秘钥key2;发送给A； 这次通信再次被中间人拦截，尽管后面的通信，两者还是用key2通信，但是中间人已经掌握了Key2;可以进行轻松的加解密；还是存在被中间人攻击风险；</p>
</li>
<li><p>解决困境：权威的证书颁发机构CA来解决； 3.1制作证书：作为服务端的A，首先把自己的公钥key1发给证书颁发机构，向证书颁发机构进行申请证书；证书颁发机构有一套自己的公私钥，CA通过自己的私钥来加密key1,并且通过服务端网址等信息生成一个证书签名，证书签名同样使用机构的私钥进行加密；制作完成后，机构将证书发给A； 3.2校验证书真伪：当B向服务端A发起请求通信的时候，A不再直接返回自己的公钥，而是返回一个证书； 说明：各大浏览器和操作系统已经维护了所有的权威证书机构的名称和公钥。B只需要知道是哪个权威机构发的证书，使用对应的机构公钥，就可以解密出证书签名；接下来，B使用同样的规则，生成自己的证书签名，如果两个签名是一致的，说明证书是有效的； 签名验证成功后，B就可以再次利用机构的公钥，解密出A的公钥key1;接下来的操作，就是和之前一样的流程了； 3.3：中间人是否会拦截发送假证书到B呢？ 因为证书的签名是由服务器端网址等信息生成的，并且通过第三方机构的私钥加密中间人无法篡改； 所以最关键的问题是证书签名的真伪；</p>
</li>
<li><p>https主要的思想是在http基础上增加了ssl安全层，即以上认证过程；:</p>
</li>
</ol>
<hr>
<h1 id="介绍下-HTTPS-中间人攻击"><a href="#介绍下-HTTPS-中间人攻击" class="headerlink" title="介绍下 HTTPS 中间人攻击"></a>介绍下 HTTPS 中间人攻击</h1><p>中间人攻击过程如下：</p>
<ol>
<li>服务器向客户端发送公钥。</li>
<li>攻击者截获公钥，保留在自己手上。</li>
<li>然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li>
<li>客户端收到伪造的公钥后，生成加密hash值发给服务器。</li>
<li>攻击者获得加密hash值，用自己的私钥解密获得真秘钥。</li>
<li>同时生成假的加密hash值，发给服务器。</li>
<li>服务器用私钥解密获得假秘钥。</li>
<li>服务器用加秘钥加密传输信息<br>防范方法：</li>
</ol>
<ul>
<li>服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性</li>
</ul>
<hr>
<h1 id="http1-0-http1-1-http2-0特性及区别"><a href="#http1-0-http1-1-http2-0特性及区别" class="headerlink" title="http1.0 http1.1 http2.0特性及区别"></a>http1.0 http1.1 http2.0特性及区别</h1><h2 id="http1-0特性"><a href="#http1-0特性" class="headerlink" title="http1.0特性"></a>http1.0特性</h2><ul>
<li>无状态：服务器不跟踪不记录请求过的状态</li>
<li>无连接：浏览器每次请求都需要建立tcp连接</li>
</ul>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录</p>
<h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>无连接导致的性能缺陷有两种：</p>
<ol>
<li><p>无法复用连接<br><br>每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</p>
</li>
<li><p>队头阻塞<br><br>http1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</p>
</li>
</ol>
<h2 id="http1-1特性"><a href="#http1-1特性" class="headerlink" title="http1.1特性"></a>http1.1特性</h2><p>为了解决http1.0的性能缺陷，http1.1出现了</p>
<p>http1.1特性：</p>
<ul>
<li>长连接：新增Connection字段，可以设置keep-alive值保持连接不断开</li>
<li>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回</li>
<li>缓存处理：新增字段cache-control</li>
<li>断点传输</li>
</ul>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>http1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据</p>
<h3 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h3><p>基于长连接的基础，我们先看没有管道化请求响应：</p>
<p>tcp没有断开，用的同一个通道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</span><br></pre></td></tr></table></figure>
<p>管道化的请求响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求1 --&gt; 请求2 --&gt; 请求3 &gt; 响应1 --&gt; 响应2 --&gt; 响应3</span><br></pre></td></tr></table></figure>
<p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p>
<p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p>
<h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求</p>
<p>通过设置字段cache-control来控制</p>
<h3 id="断点传输"><a href="#断点传输" class="headerlink" title="断点传输"></a>断点传输</h3><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p>
<p>在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range</p>
<h2 id="http2-0特性"><a href="#http2-0特性" class="headerlink" title="http2.0特性"></a>http2.0特性</h2><ul>
<li>二进制分帧</li>
<li>多路复用： 在共享TCP链接的基础上同时发送请求和响应</li>
<li>头部压缩</li>
<li>服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求</li>
</ul>
<h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>http1.0 到http1.1的主要区别，就是从无连接到长连接</li>
<li>http2.0对比1.X版本主要区别就是多路复用</li>
</ul>
<hr>
<h1 id="永久性重定向（301）和临时性重定向（302）对-SEO-有什么影响"><a href="#永久性重定向（301）和临时性重定向（302）对-SEO-有什么影响" class="headerlink" title="永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响"></a>永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响</h1><p>1）301 redirect——301代表永久性转移(Permanently Moved)，301重定向是网页更改地址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况,都建议使用301来做转址。 如果我们把一个地址采用301跳转方式跳转的话，搜索引擎会把老地址的PageRank等信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。旧网址的排名等完全清零</p>
<p>（2）302 redirect——302代表暂时性转移(Temporarily Moved )，在前些年，不少Black Hat SEO曾广泛应用这项技术作弊，目前，各大主要搜索引擎均加强了打击力度，象Google前些年对Business.com以及近来对BMW德国网站的惩罚。即使网站客观上不是spam，也很容易被搜寻引擎容易误判为spam而遭到惩罚。</p>
<hr>
<h1 id="Http-状态码-301-和-302-的应用场景分别是什么"><a href="#Http-状态码-301-和-302-的应用场景分别是什么" class="headerlink" title="Http 状态码 301 和 302 的应用场景分别是什么"></a>Http 状态码 301 和 302 的应用场景分别是什么</h1><p>301应用场景: 域名到期不想继续用这个,换了地址<br>302应用场景: 做活动时候,从首页跳到活动页面,</p>
<hr>
<h1 id="接口如何防刷"><a href="#接口如何防刷" class="headerlink" title="接口如何防刷"></a>接口如何防刷</h1><ol>
<li>网关控制流量洪峰，对在一个时间段内出现流量异常，可以拒绝请求</li>
<li>源ip请求个数限制。对请求来源的ip请求个数做限制 </li>
<li>http请求头信息校验；（例如host，User-Agent，Referer）</li>
<li>对用户唯一身份uid进行限制和校验。例如基本的长度，组合方式，甚至有效性进行判断。或者uid具有一定的时效性</li>
<li>前后端协议采用二进制方式进行交互或者协议采用签名机制 </li>
<li>人机验证，验证码，短信验证码，滑动图片形式，12306形式</li>
</ol>
<hr>
<h1 id="为什么-HTTP1-1-不能实现多路复用"><a href="#为什么-HTTP1-1-不能实现多路复用" class="headerlink" title="为什么 HTTP1.1 不能实现多路复用"></a>为什么 HTTP1.1 不能实现多路复用</h1><p>HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。</p>
<hr>
<h1 id="HTTP报文结构是什么"><a href="#HTTP报文结构是什么" class="headerlink" title="HTTP报文结构是什么"></a>HTTP报文结构是什么</h1><p>对于 TCP 而言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起始行 + 头部 + 空行 + 实体</span><br></pre></td></tr></table></figure>
<blockquote>
<p>空行是用来分开头部和实体。</p>
</blockquote>
<ol>
<li>请求报文</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730d8b6a53d2d7a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<ol start="2">
<li>响应报文</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730d8b8b2a02d6f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<hr>
<h1 id="HTTP请求方法有哪些"><a href="#HTTP请求方法有哪些" class="headerlink" title="HTTP请求方法有哪些"></a>HTTP请求方法有哪些</h1><ul>
<li>GET方法，用来获取资源</li>
<li>POST方法，用来提交数据</li>
<li>PUT方法，用来修改数据</li>
<li>DELETE方法，用来删除资源</li>
<li>OPTIONS方法，用来跨域请求</li>
<li>HEAD方法，用来获取资源的元信息</li>
<li>CONNECT方法，用来建立连接，用于代理服务器</li>
<li></li>
</ul>
<hr>
<h1 id="对URI是如何理解的"><a href="#对URI是如何理解的" class="headerlink" title="对URI是如何理解的"></a>对URI是如何理解的</h1><p>URL统一资源定位符，URI，统一资源标识符。URI用于区分网络上不同的资源。</p>
<p>URI包含了URN和URL。</p>
<p>URL的结构：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730d922c915cb25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<blockquote>
<p>协议名，登录主机的用户信息，主机名和端口，请求路径，查询参数，URI上定位资源内的一个锚点。</p>
</blockquote>
<hr>
<h1 id="对HTTP状态码的了解"><a href="#对HTTP状态码的了解" class="headerlink" title="对HTTP状态码的了解"></a>对HTTP状态码的了解</h1><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730d9c4c31cebad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730d9ff3358a7db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<hr>
<h1 id="说说HTTP特点以及缺点"><a href="#说说HTTP特点以及缺点" class="headerlink" title="说说HTTP特点以及缺点"></a>说说HTTP特点以及缺点</h1><p>特点是：</p>
<p>灵活可扩展<br>可靠传输<br>无状态等<br>缺点是：</p>
<p>无状态<br>明文传输<br>队头阻塞问题</p>
<hr>
<h1 id="对Accept字段的理解"><a href="#对Accept字段的理解" class="headerlink" title="对Accept字段的理解"></a>对Accept字段的理解</h1><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730da1b00192b77?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730da3125c65de9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<ul>
<li>数据格式</li>
<li>压缩方式</li>
<li>支持语言</li>
<li>字符集</li>
</ul>
<hr>
<h1 id="什么是队头阻塞问题"><a href="#什么是队头阻塞问题" class="headerlink" title="什么是队头阻塞问题"></a>什么是队头阻塞问题</h1><p>TCP中是报文，HTTP是请求。</p>
<p>对于解决HTTP的队头阻塞问题是：并发连接和域名分片。</p>
<h1 id="对HTTP代理的理解"><a href="#对HTTP代理的理解" class="headerlink" title="对HTTP代理的理解"></a>对HTTP代理的理解</h1><p>代理服务器功能：</p>
<ol>
<li>负载均衡;</li>
<li>保障安全（利用心跳机制监控服务器，一旦发现故障机就将其踢出集群。）;</li>
<li>缓存代理;</li>
</ol>
<p>理解代理缓存：</p>
<ul>
<li>由一个代理服务器下载的页面存储；</li>
<li>一个代理服务器为多个用户提供一条通道；</li>
<li>缓冲的代理允许一个代理服务器减少对同一个网站的同样页面的请求次数</li>
<li>一旦代理服务器的一个用户请求了某个页面，代理服务器就保存该页面以服务于它的其他用户的同样的请求</li>
<li>代理缓存，这种处理减少了用户等待页面显示的时间</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730e1d851e2612e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>缓存的作用：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730e3846c985a5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<blockquote>
<p>代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可减少对源服务器的访问，可以节省通信流量和通信时间。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;300；</span><br></pre></td></tr></table></figure>
<p>表示时间间隔，再次请求的时间间隔300s内，就在缓存中获取，否则就在服务器中</p>
<p>Cache-Control:</p>
<ul>
<li>public 表示响应可被任何中间节点缓存</li>
<li>private 表示中间节点不允许缓存</li>
<li>no-cache 表示不使用Cache-Control的缓存控制方式做前置验证</li>
<li>no-store 表示真正的不缓存任何东西</li>
<li>max-age 表示当前资源的有效时间</li>
</ul>
<p>强缓存：浏览器直接从本地存储中获取数据，不与服务器进行交互</p>
<p>协商缓存：浏览器发送请求到服务器，浏览器判断是否可使用本地缓存</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存主要学习expires和cache-control</p>
<p>cache-control该字段：max-age，s-maxage，public，private，no-cache，no-store。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: public, max-age&#x3D;3600, s-maxage&#x3D;3600</span><br></pre></td></tr></table></figure>
<ul>
<li>表示资源过了多少秒之后变为无效</li>
<li>s-maxage 的优先级高于 max-age</li>
<li>在代理服务器中，只有 s-maxage 起作用</li>
</ul>
<p>public 和 private</p>
<ul>
<li>public 表示该资源可以被所有客户端和代理服务器缓存</li>
<li>private 表示该资源仅能客户端缓存</li>
</ul>
<p>当浏览器去请求某个文件的时候，服务端就在response header里做了缓存的配置：</p>
<blockquote>
<p>表现为：respone header 的cache-control</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730e3a45add53fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730e40361679b99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>response header里面的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etag: &#39;xxxx-xxx</span><br><span class="line">last-modified: xx, 24 Dec xxx xxx:xx:xx GMT</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730e4ccfb831f4c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730e50ac0c7b4d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730e54ea7d82497?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<hr>
<h1 id="关于HTTP-2"><a href="#关于HTTP-2" class="headerlink" title="关于HTTP/2"></a>关于HTTP/2</h1><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/7/2/1730e6a4b02fba2f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>HTTP/2采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SmileLJZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://smileljz.github.io/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">https://smileljz.github.io/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://SmileLJZ.github.io" target="_blank">SmileLJZ 个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/http-TCP/">http/TCP</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/14/TypeScript%EF%BC%885%EF%BC%89/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TypeScript（5）</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By SmileLJZ</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script></body></html>