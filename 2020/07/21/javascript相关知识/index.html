<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>javascript相关知识 | SmileLJZ 个人博客</title><meta name="description" content="CSS 用于控制网页的样式和布局。"><meta name="keywords" content="javascript"><meta name="author" content="SmileLJZ"><meta name="copyright" content="SmileLJZ"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://smileljz.github.io/2020/07/21/javascript%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="javascript相关知识"><meta property="og:url" content="https://smileljz.github.io/2020/07/21/javascript%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><meta property="og:site_name" content="SmileLJZ 个人博客"><meta property="og:description" content="CSS 用于控制网页的样式和布局。"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-07-20T22:39:11.000Z"><meta property="article:modified_time" content="2020-07-21T00:03:04.223Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="css相关知识" href="https://smileljz.github.io/2020/07/20/css%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="SmileLJZ 个人博客" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://pic.downk.cc/item/5f040b5a14195aa5946dfd5f.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面对对象（OOP）"><span class="toc-number">1.</span> <span class="toc-text">面对对象（OOP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现思路"><span class="toc-number">1.1.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型概念"><span class="toc-number">1.2.</span> <span class="toc-text">原型概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象创建"><span class="toc-number">1.3.</span> <span class="toc-text">对象创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查看对象原型"><span class="toc-number">1.4.</span> <span class="toc-text">查看对象原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型的用法"><span class="toc-number">1.5.</span> <span class="toc-text">原型的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型链"><span class="toc-number">1.6.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#"><span class="toc-number">1.7.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Javascript-的作用域和作用域链"><span class="toc-number">2.</span> <span class="toc-text">Javascript 的作用域和作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是作用域"><span class="toc-number">2.1.</span> <span class="toc-text">什么是作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#（1）作用域的定义："><span class="toc-number">2.1.1.</span> <span class="toc-text">（1）作用域的定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（2）词法作用域"><span class="toc-number">2.1.2.</span> <span class="toc-text">（2）词法作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（3）块级作用域"><span class="toc-number">2.1.3.</span> <span class="toc-text">（3）块级作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域链"><span class="toc-number">2.2.</span> <span class="toc-text">作用域链</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包"><span class="toc-number">3.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#（1）从实例解析闭包"><span class="toc-number">3.1.</span> <span class="toc-text">（1）从实例解析闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包的用途"><span class="toc-number">3.2.</span> <span class="toc-text">闭包的用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包的实际应用"><span class="toc-number">3.3.</span> <span class="toc-text">闭包的实际应用</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SmileLJZ 个人博客</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">javascript相关知识</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-21 06:39:11"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-21 08:03:04"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="面对对象（OOP）"><a href="#面对对象（OOP）" class="headerlink" title="面对对象（OOP）"></a>面对对象（OOP）</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>面对对象是大家都很熟悉的程序设计思想，是对真实世界的抽象，目前主要OOP语言用来实现面对对象的基础是类，通过类的封装，继承来映射真实世界。包括Java，C#，甚至是python等都通过类的设计来实现面对对象。但是细想起来也会觉得有问题，因为真实世界其实没有类这种概念，只有一个个不同的对象，真实世界中，继承关系发生在对象和对象之间，而不是类。就比如孩子是对象，父母也是对象，孩子（对象）继承自父母（对象）<br>JS也是面对对象的编程语言，只不过它实现面对对象的思路是基于原型（prototype）,而不是类。这种思路也叫对象关联（Object Link Other Object），即在对象上直接映射那种真实世界的关系（如继承）。</p>
<h2 id="原型概念"><a href="#原型概念" class="headerlink" title="原型概念"></a>原型概念</h2><p>JS中一切皆对象，而每个对象都有一个原型（Object除外），这个原型，大概就像Java中的父类，所以，基本上你可以认为原型就是这个对象的父对象，即每一个对象（Object除外）内部都保存了它自己的父对象，这个父对象就是原型。一般创建的对象如果没有特别指定原型，那么它的原型就是Object(这就很类似Java中所有的类默认继承自Object类)。</p>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>在JS中，对象创建的方法有很多种，最常见的如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种，手动创建</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;<span class="string">'name'</span>:<span class="string">'lala'</span>&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种，构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'lala'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种，class (ES6标准写法)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">//super();此处没有使用extends显式继承，不可使用super()</span></span><br><span class="line">        <span class="keyword">this</span>.name=<span class="string">'lala'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A()</span><br><span class="line"><span class="comment">//其实后面两种方法本质上是一种写法</span></span><br></pre></td></tr></table></figure>
<p>这三种写法创建的对象的原型（父对象）都是Object,需要提到的是，ES6通过引入class ,extends等关键字，以一种语法糖的形式把构造函数包装成类的概念，更便于大家理解。是希望开发者不再花精力去关注原型以及原型链，也充分说明原型的设计意图和类是一样的。</p>
<h2 id="查看对象原型"><a href="#查看对象原型" class="headerlink" title="查看对象原型"></a>查看对象原型</h2><p>当对象被创建之后，查看它们的原型的方法不止一种，以前一般使用对象的proto属性，ES6推出后，推荐用Object.getPrototypeOf()方法来获取对象的原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'lala'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(A.prototype)  </span><br><span class="line"><span class="comment">//输出：Object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(A.__proto__)  </span><br><span class="line"><span class="comment">//输出：function () &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(A))</span><br><span class="line"><span class="comment">//输出：function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>无论对象是如何创建的，默认原型都是Object，在这里需要提及的比较特殊的一点就是，通过构造函数来创建对象，函数A本身也是一个对象，而A有两个指向表示原型的属性，分别是proto和prototype，而且两个属性并不相同</p>
<p>函数的的prototype属性只有在当作构造函数创建的时候，把自身的prototype属性值赋给对象的原型。而实际上，作为函数本身，它的原型应该是function对象，然后function对象的原型才是Object。<br>总之，建议使用ES6推荐的查看原型和设置原型的方法。</p>
<h2 id="原型的用法"><a href="#原型的用法" class="headerlink" title="原型的用法"></a>原型的用法</h2><p>其实原型和类的继承的用法是一致的：当你想用某个对象的属性时，将当前对象的原型指向该对象，你就拥有了该对象的使用权了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'world '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bb=<span class="string">"hello"</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</span><br><span class="line"><span class="comment">//将b设置为a的原型,此处有一个问题，即a的constructor也指向了B构造函数，可能需要纠正</span></span><br><span class="line">a.constructor=A;</span><br><span class="line"><span class="built_in">console</span>.log(a.bb)</span><br><span class="line"><span class="comment">//输出 hello</span></span><br></pre></td></tr></table></figure>
<p>如果使用ES6来做的话则简单许多，甚至不涉及到prototype这个属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.bb=<span class="string">'hello'</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.name=<span class="string">'world'</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a.bb+<span class="string">" "</span>+a.name);</span><br><span class="line"><span class="comment">//输出hello world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(A))</span><br><span class="line"><span class="comment">//输出  "function"</span></span><br></pre></td></tr></table></figure>

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>这个概念其实也变得比较简单，可以类比类的继承链条，即每个对象的原型往上追溯，一直到Object为止，这组成了一个链条，将其中的对象串联起来，当查找当前对象的属性时，如果没找到，就会沿着这个链条去查找，一直到Object，如果还没发现，就会报undefined。那么也就意味着你的原型链不能太长，否则会出现效率问题。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><ul>
<li>对于原型概念的理解<ul>
<li>类比类的继承，对象的原型可以理解为对象的父对象</li>
</ul>
</li>
</ul>
<ul>
<li>原型的运用<ul>
<li>尽可能使用ES6的标准，使用class，extends,Object.getPrototype(),Object.setPrototype()等等</li>
</ul>
</li>
</ul>
<ul>
<li>需要注意的点<ul>
<li>原型继承链条不要太长</li>
<li>指定原型时，注意constructor也会改变。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Javascript-的作用域和作用域链"><a href="#Javascript-的作用域和作用域链" class="headerlink" title="Javascript 的作用域和作用域链"></a>Javascript 的作用域和作用域链</h1><p>作用域： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。<br>作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和<br>函数。<br>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前<br>端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p>
<h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><p>先看这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Jake Zhang'</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(name); </span><br><span class="line">&#125;</span><br><span class="line">fun();<span class="comment">// 输出"Jake Zhang"</span></span><br></pre></td></tr></table></figure>
<p>在fun() 执行的时候，输出一个name变量 ，那么这个name变量是哪里来？有看到函数第一行有 定义 name变量的代码var name = ‘Jake Zhang’</p>
<p>继续看另外一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name2 = <span class="string">'Jake Zhang2'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(name2);</span><br><span class="line">&#125;</span><br><span class="line">fun(); <span class="comment">// 输出"Jake Zhang2"</span></span><br></pre></td></tr></table></figure>

<p>同样，在输出 name2 时，自己函数内部没有找到变量name2 ，那么就 在外层的全局中查找 ，找到了就停止查找并输出结果。</p>
<p>可以注意到以上两段代码都有查找变量。第一段代码是在函数fun中找到name变量，第二段代码是在全局中找到name2变量。 现在给加粗的这两个词的后面加上作用域三个字，再读一遍：第一段代码是在函数作用域fun中找到name变量，第二段代码是在全局作用域中找到name2变量。</p>
<p>其实我们可以发现，作用域，本质是一套规则，用于确定在何处以及如何查找变量（标识符）的规则。关键点在于：查找变量（或标识符）。</p>
<p>由此我们便可引出</p>
<h3 id="（1）作用域的定义："><a href="#（1）作用域的定义：" class="headerlink" title="（1）作用域的定义："></a>（1）作用域的定义：</h3><p>作用域是定义变量的区域，它有一套访问变量的规则，这套规则用来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</p>
<h3 id="（2）词法作用域"><a href="#（2）词法作用域" class="headerlink" title="（2）词法作用域"></a>（2）词法作用域</h3><p>在上面的作用域介绍中，我们将作用域定义为一套规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</p>
<p>现在我们提出一个概念：“词法作用域是作用域的一种工作模型”，作用域有两种工作模型，在JavaScript中的词法作用域（静态作用域）是比较主流的一种，另一种动态作用域（是不关心函数和变量是如何声明以及在何处声明的，只关心它们从何处调用）。<br>所谓的词法作用域就是在你写代码时将变量和块作用域写在哪里来决定，也就是词法作用域是静态的作用域，在你书写代码时就确定了。</p>
<p>请看以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = x + <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(x, y, z);</span><br><span class="line">	&#125;</span><br><span class="line">	fn2(y * <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">6</span>); <span class="comment">// 6 10 50</span></span><br></pre></td></tr></table></figure>
<p>复制代码这个例子中有个三个嵌套的作用域，如图：<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/4/13/17172d279d13922c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<ul>
<li>A 为全局作用域，有一个标识符：fn1</li>
<li>B 为fn1所创建的作用域，有三个标识符：x、y、fn2</li>
<li>C为fn2所创建的作用域，有一个标识符：z<br>作用域是由其代码写在哪里决定的，并且是逐级包含的。</li>
</ul>
<h3 id="（3）块级作用域"><a href="#（3）块级作用域" class="headerlink" title="（3）块级作用域"></a>（3）块级作用域</h3><p>在ES6之前JavaScript并没有块级作用域的概念，我们来看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.i)</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">//0 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>如果你没在函数内使用<code>for</code>循环的话，你会惊奇的发现，妈耶，我这个<code>var</code>不等于白<code>var</code>嘛，反正都是全局变量，要知道我们的变量只能从下往上查找，不能反过来。所以<code>JavaScript</code>并没有块级作用域的概念。<br>块级作用域是ES6中新添加的概念，常指的是{}中的语句，如 <code>if</code> 和 <code>switch</code> 条件语句或 <code>for</code>和 <code>while</code> 循环语句，不像函数，它们不会创建一个新的作用域。块级作用域通常通过<code>let</code>或<code>const</code>来体现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)(<span class="built_in">console</span>.log(<span class="built_in">window</span>.j));<span class="comment">//undefined *5</span></span><br></pre></td></tr></table></figure>

<p>看上面的代码，可以和上一个的<code>var i</code>的循环做对比。其实，提到let，const，这里还涉及到变量提升、暂时性死区等知识点。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>我们回到刚开始讲作用域的那段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name2 = <span class="string">'Jake Zhang2'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(name2);</span><br><span class="line">&#125;</span><br><span class="line">fun(); <span class="comment">// 输出"Jake Zhang2"</span></span><br></pre></td></tr></table></figure>
<p>我们在查找 name2 变量时，先在函数作用域中 查找，没有找到，再去 全局作用域中 查找。你会注意到，这是一个往外层查找的过程，即顺着一条链条 从下往上查找变量 。这条链条，我们就称之为作用域链。<br>这样我们就得出作用域链的概念：在作用域的多层嵌套中查找自由变量的过程是作用域链的访问机制。而层层嵌套的作用域，通过访问自由变量形成的关系叫做作用域链。</p>
<p>来两张图帮助理解：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/4/13/171732353113a982?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/4/13/171733125b9957c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<hr>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>前面所说的作用域及词法作用域都是为讲闭包做准备，词法作用域也是理解闭包的前置知识，所以如果对 作用域还有点模糊的可以回头再看一遍。</p>
<h2 id="（1）从实例解析闭包"><a href="#（1）从实例解析闭包" class="headerlink" title="（1）从实例解析闭包"></a>（1）从实例解析闭包</h2><p>闭包（closure），是基于词法作用域书写代码时产生的一种现象。各种专业文献的闭包定义都非常抽象，我的理解是:** 闭包就是能够读取其他函数内部变量的函数**。通过下面的实践你会知道，闭包在代码中随处可见，不用特意为其创建而创建，随着深入做项目后，打代码的不经意间就已经用了闭包。</p>
<p><strong>实例1：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       n++;</span><br><span class="line">       <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1 = a(); <span class="comment">//注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span></span><br><span class="line">a1();    <span class="comment">//1</span></span><br><span class="line">a1();    <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>分析如下：</p>
<ul>
<li>add的词法作用域能访问a的作用域。根据条件执行a函数内的代码，add当做值返回；</li>
<li>add执行后，将a的引用赋值给a1；</li>
<li>执行a1，分别输出1，2</li>
</ul>
<p>通过引用的关系，<code>a1</code>就是<code>a</code>函数本身（<code>a1=a</code>）。执行<code>a1</code>能正常输出变量<code>n</code>的值，这不就是“<code>a</code>能记住并访问它所在的词法作用域”，而<code>a</code>（被<code>a1</code>调用）的运行是在当前词法作用域之外。</p>
<p>当<code>add</code>函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器 会释放闭包那段内存空间，但是闭包就这样神奇地将<code>add</code>的作用域存活了下来，<code>a</code>依然持有该作用域的引用。</p>
<p>为什么会这样呢？原因就在于<code>a</code>是<code>add</code>的父函数，而<code>add</code>被赋给了一个全局变量，这导致<code>add</code>始终在内存中，而<code>add</code>的存在依赖于a，因此a也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。<br>所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。<br><strong>总结：闭包就是一个函数引用另外一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。</strong></p>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><p>闭包可以用在许多地方。它的最大用处有两个，<strong>一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中</strong>。</p>
<h2 id="闭包的实际应用"><a href="#闭包的实际应用" class="headerlink" title="闭包的实际应用"></a>闭包的实际应用</h2><p>使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。</p>
<p><strong>实例2：随处可见的定时器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitSomeTime</span>(<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(msg)</span><br><span class="line">	&#125;, time);</span><br><span class="line">&#125;</span><br><span class="line">waitSomeTime(<span class="string">'hello'</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>定时器中有一个匿名函数，该匿名函数就有涵盖waitSomeTime函数作用域的闭包，因此当1秒之后，该匿名函数能输出msg。</p>
<p><strong>实例3：用for循环输出函数值的问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  fnArr[i] =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( fnArr[<span class="number">3</span>]() ) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>通过<code>for</code>循环，预期的结果我们是会输出0-9，但最后执行的结果，在控制台上显示则是全局作用域下的10个10。<br>这是因为当我们执行<code>fnArr[3]</code>时，先从它当前作用域中找 <code>i</code> 的变量，没找到<code>i</code> 变量，从全局作用域下找。开始了从上到下的代码执行，要执行匿名函数<code>function</code>时，<code>for</code>循环已经结束（<code>for</code>循环结束的条件是当<code>i</code>大于或等于10时，就结束循环），然后执行函数<code>function</code>，此时当 <code>i</code> 等于<code>[0,1,2,3,4,5,6,7,8,9]</code>时，此时i 再执行函数代码，输出值都是 <code>i</code> 循环结束时的最终值为：10，所以是输出10次10。<br>由此可知：<code>i</code>是声明在全局作用域中，<code>function</code>匿名函数也是执行在全局作用域中，那当然是每次都输出10了。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SmileLJZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://smileljz.github.io/2020/07/21/javascript%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">https://smileljz.github.io/2020/07/21/javascript%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://SmileLJZ.github.io" target="_blank">SmileLJZ 个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javascript/">javascript</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/20/css%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">css相关知识</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/12/TypeScript（1）/" title="TypeScript1"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-12</div><div class="relatedPosts_title">TypeScript1</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/12/TypeScript（2）/" title="TypeScript2"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-12</div><div class="relatedPosts_title">TypeScript2</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/12/TypeScript（3）/" title="TypeScript（3）"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-12</div><div class="relatedPosts_title">TypeScript（3）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/14/TypeScript（4）/" title="TypeScript（4）"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-14</div><div class="relatedPosts_title">TypeScript（4）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/14/TypeScript（5）/" title="TypeScript（5）"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-14</div><div class="relatedPosts_title">TypeScript（5）</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By SmileLJZ</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script></body></html>